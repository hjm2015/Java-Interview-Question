# 面试题-Java虚拟机相关（JVM）

## 1.类加载器

### 1.1、有哪些类加载器。

常见的类加载器有以下4种：

1. **BootstrapClassLoader 引导类加载器**，由 C 语言编写的；负责加载JRE lib目录下的核心类库，比如 rt.jar-String.java 类；
2. **ExtClassLoader** **扩展类加载器**；负责加载JRE lib目录下 ext 扩展目录中的JAR类包。
3. **AppClassLoader 应用类加载器**；复杂加载Classpath路径下的类包，主要加载编码人员所写的类
4. **自定义加载器**，通过实现一个继承了 ClassLoader 的类，负责加载用户所自定义的路径的类包

### 1.2、双亲委派模型

![类加载器](https://github.com/hjm2015/Java-Interview-Question/blob/main/photo/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/classLoader.png)

​		由于Java提供的类加载器有父子关系（不是Java中的继承）,类加载器的属性中有个parent属性，由于应用程序类加载器的parent是扩展类加载器，所以当应用程序类加载器加载一个类的时候会先检查自己是否已经加载过该类，如果没有，则委托给他的parent-扩展类加载器去负责加载，同理扩展类加载器加载器的parent是个 null，因为引导类加载器是由c源码编写的，所以当parent是空的时候，默认去调用引导类加载器；当引导类加载器没有的查找到该类的时候，就继续由扩展类加载器进行加载，同理扩展类加载器没有查找到该类的时候，则由应用程序类加载器进行加载，如果都没有则抛出异常；如果找到了的话，会将该类缓存起来，方便下次再次进行类加载。

**双亲委派模型简单的来说，就是先由父亲加载，找不到再由儿子自己加载。**

**双亲委派模型的好处：**

- **沙箱安全机制：自己所写的java.lang.String类不会被加载，这样便可以防止核心API库被随意更改**
- **避免类的重复加载：当父类已经加载了该类的时候，子类就没有必要再加载一次，保证了类的唯一性。**

### 1.3、能不能自己写一个类叫java.lang.String

不能，由于双亲委派机制的原因。java.lang.String 类俗语 JRE lib 目录下的核心类库，所以当实现类加载自定义的 String 的时候，会交由 BootstrapClassLoader 引导类加载器 进行加载。

### 1.4、双亲委派模式，哪些场景是打破双亲委派模式

比较常见的就是Tomcat,Tomcat有自定义类加载器就是打破了双亲委派机制。有以下的两个场景

1. 我们要怎么实现jsp文件的热加载，jsp 文件编译后其实也就是class文 件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的class对象，修改后的jsp 是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载 器。重新创建类加载器，重新加载jsp文件。
2. 如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认 的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 所以如果使用双亲委派机制，当在一个tomcat中部署多个项目，但是多个项目中依赖的jar包一样，但是版本不一样就会导致异常
