# 面试题-Java虚拟机相关（JVM）

## 1.类加载器

### 1.1、有哪些类加载器。

常见的类加载器有以下4种：

1. **BootstrapClassLoader 引导类加载器**，由 C 语言编写的；负责加载JRE lib目录下的核心类库，比如 rt.jar-String.java 类；
2. **ExtClassLoader** **扩展类加载器**；负责加载JRE lib目录下 ext 扩展目录中的JAR类包。
3. **AppClassLoader 应用类加载器**；复杂加载Classpath路径下的类包，主要加载编码人员所写的类
4. **自定义加载器**，通过实现一个继承了 ClassLoader 的类，负责加载用户所自定义的路径的类包

### 1.2、双亲委派模型

![类加载器](https://github.com/hjm2015/Java-Interview-Question/blob/main/photo/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/classLoader.png)

​		由于Java提供的类加载器有父子关系（不是Java中的继承）,类加载器的属性中有个parent属性，由于应用程序类加载器的parent是扩展类加载器，所以当应用程序类加载器加载一个类的时候会先检查自己是否已经加载过该类，如果没有，则委托给他的parent-扩展类加载器去负责加载，同理扩展类加载器加载器的parent是个 null，因为引导类加载器是由c源码编写的，所以当parent是空的时候，默认去调用引导类加载器；当引导类加载器没有的查找到该类的时候，就继续由扩展类加载器进行加载，同理扩展类加载器没有查找到该类的时候，则由应用程序类加载器进行加载，如果都没有则抛出异常；如果找到了的话，会将该类缓存起来，方便下次再次进行类加载。

**双亲委派模型简单的来说，就是先由父亲加载，找不到再由儿子自己加载。**

**双亲委派模型的好处：**

- **沙箱安全机制：自己所写的java.lang.String类不会被加载，这样便可以防止核心API库被随意更改**
- **避免类的重复加载：当父类已经加载了该类的时候，子类就没有必要再加载一次，保证了类的唯一性。**

### 1.3、能不能自己写一个类叫java.lang.String

不能，由于双亲委派机制的原因。java.lang.String 类俗语 JRE lib 目录下的核心类库，所以当实现类加载自定义的 String 的时候，会交由 BootstrapClassLoader 引导类加载器 进行加载。

### 1.4、双亲委派模式，哪些场景是打破双亲委派模式

比较常见的就是Tomcat,Tomcat有自定义类加载器就是打破了双亲委派机制。有以下的两个场景

1. 我们要怎么实现jsp文件的热加载，jsp 文件编译后其实也就是class文 件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的class对象，修改后的jsp 是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载 器。重新创建类加载器，重新加载jsp文件。
2. 如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认 的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 所以如果使用双亲委派机制，当在一个tomcat中部署多个项目，但是多个项目中依赖的jar包一样，但是版本不一样就会导致异常

## 2.垃圾回收算法

### 2.1 Java 中垃圾回收机制中如何判断对象需要回收？

JVM 常见的有两种方法实现判断对象是否需要回收：

- 引用计数法：引用计数法简单的来说就是记录到底有多少个引用指向当前对象，如果当前引用的计数等于0，则表示该对象是个垃圾对象，需要被回收；但是**一般该方法不推荐使用，判断相互依赖的对象是否为垃圾（A 对象引用 B ， B 对象引用 A），实现起来相对麻烦。**
- 可达性分析法（推荐使用）：HopSpot 虚拟机使用的就是该方法。通过筛选到 GCRoot 根节点，然后根据 GC Root 根节点，使用**三色标记法**去标记存活的对象，剩下的就是垃圾对象。

### 2.2  常见的 GC算法有哪些？

常见的GC算法有以下3种：

1. **标记清除算法**：标记清除算法，通过标记存活的对象，然后将剩下没有标记的对象进行清除；或者标记垃圾对象，清除标记的对象，剩下的对象就是存活的对象。基于虚拟机的实现。
   1. 优点：标记清除对象，在清除的阶段不需要移动对象，因此可以与业务线程并发执行，不需要STW。
   2. 缺点：标记清除对象，因为不需要移动对象，因此会导致存在大量的空间碎片；清除效率不稳定，会随着存活的对象增加导致清除的时间变长。
2. **标记复制算法**：通过将一块内存区域划分为两块，使用一块区域A进行内存分配，另一块区域B备用；当区域A放不下的时候会触发垃圾回收，将存活的对象标记，将存活的对象复制到区域B，此时改为区域B进行内存的分配；
   1. 优点：不会产生内存碎片
   2. 缺点：会造成内存的浪费；并且会移动对象，会导致STW；
   3. 场景：常用于年轻代，因为年轻代的对象是朝生夕死的对象，因此存活的对象相对来说较少，因此复制移动的开销会变少。
3. **标记整理算法**：标记整理与标记清除算法基本类似，有额外的区别就是整理算法有个压缩操作，将存活的对象往同一个区域挪动，消灭了内存碎片，但因为需要移动对象所以会造成STW。
   1. 优点：不会产生内存碎片
   2. 缺点：会造成STW

